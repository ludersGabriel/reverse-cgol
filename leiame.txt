Eduardo Vudala Senoski - GRR20195689
Gabriel Lüders - GRR20190172

Jogo da vida reverso

O objetivo do trabalho é reverter o Jogo da Vida de Conway de maneira a encontrar um estado imediatamente anterior e mínimo. Como várias técnicas diferentes podiam ser utilizadas, desde buscas clássicas a algoritmos genéticos, o passo inicial da equipe foi pesquisar e entender as abordagens possíveis.

Como o Jogo da Vida é um sistema bem estudado, a equipe encontrou uma Wiki referente ao assunto, https://conwaylife.com/wiki, além de um fórum de discussões, https://conwaylife.com/forums/, e um servidor no discord. Em conversas com os membros ativos da comunidade de resolução de problemas relacionados ao Jogo da Vida, descobriu-se que buscas utilizando SAT solvers são a abordagem mais comum e eficiente para o problema. Isso se dá devido a não bijetividade do problema, ou seja, a existência de múltiplos estados anteriores para um mesmo estado atual, além da dificuldade em caminhar entre os estados, visto que é muito difícil valorar a importância de cada célula viva ou morta para o estado anterior.

Com isso em mente, o próximo passo era encontrar um solver que fosse capaz de resolver o problema da melhor maneira. Lendo a Wiki, descobriu-se que o Kissat é um dos solvers mais rápidos atualmente e que há um programa chamado "Logic Life Search" (LLS), https://conwaylife.com/wiki/Logic_Life_Search, que é capaz de converter um tabuleiro do jogo da vida qualquer em um formato CNF de maneira eficiente, testadamente correta e rápida, além de ser capaz de permitir restrições populacionais e ser capaz de rodar o Kissat para resolver uma instância do problema, mas não para minimizar o número de células vivas de maneira automatica.

Com isso em mãos e com a liberação do professor, batava encontra uma maneira de utilizar essas ferramentas em conjunto de maneira a minimizar a solução e fornecer a saída esperada para o professor.

Para isso, a equipe decidiu realizar uma busca binária dentro do espaço possível de soluções da seguinte maneira: após devidas conversões da entrada fornecida do professor para o formato de busca do LLS, o LLS é invocado encontrar um predecessor, mas sem restrições de população, visto que é extremamente rápido para isso. Uma vez encontrada a solução inicial, um range de população é definido com low = 0 e high = população da solução inicial. A cada iteração, o LLS é invocado com restrições de população low <= população <= high. Se o LLS retornar uma solução, high recebe o valor da população da resposta - 1, caso contrário low recebe o valor da população da resposta + 1. O processo é repetido até que low > high, momento em que a solução é retornada.

Essa busca binária em conjunto com o LLS e as restrições populacionais garante que a solução ótima é sempre encontrada, mas se mostrou suficientemente eficiente para tabuleiros de no máximo 20x20 dadas as restrições de processamento do trabalho. Para tabuleiros maiores, o programa se torna instável, fornecendo respostas após tempo de processamento que varia entre 10 segundos até dias. Essa instabilidade se da devido a complexidade inata do problema e da natureza exponencial de soluções SAT em geral. O grupo notou que, para certos tabuleiros 25x25, o programa levava dias para retornar uma resposta porque estava, literalmente, testando todas as variações do espaço de estado de maneira a encontrar, ou não, uma solução para determinada restrição de população.

Para remediar esse problema, a equipe implementou um sistema de timeout que limita o tempo de execução do LLS a 30 segundos. Caso uma resposta não seja encontrada, o programa retorna UNSAT, sobe o limite inferior da busca binária, e tenta novamente. Esse sistema garante que o programa sempre retorna uma resposta, mas não garante que a resposta seja a ótima.

A dupla decidiu seguir dessa forma visto que o LLS, em tabuleiros computáveis até os limites comentados acima, é extremamente rápido. Dessa forma, a ideia foi que se uma resposta não fosse encontrada rápida o suficiente, mesmo que não fosse UNSAT, o tempo de processamento seria muito grande para ser considerado uma solução viável. Dessa maneira, uma vez que a solução inicial é encontrada rapidamente visto que não há restrição populacional, ao menos uma resposta sempre é retornada, mesmo que não seja a ideal.

Outras ideias também foram consideradas, como filtragens do espaço de busca e modificações da máscara de busca do LLS, mas, após testes, notou-se que a dupla não foi capaz de encontrar uma maneira de eliminar tabuleiros UNSAT sem, ao mesmo tempo, eliminar o estado objetivo para certas instâncias do problema.

Algumas outras melhorias para a nossa proposta seriam a implementação de retry para as instâncias que foram abortadas caso o tempo total de execução não tenha sido atingido e uma resposta já tenha sido encontrada, além de paralelizar o processo de busca binária, o que não foi implementado visto que o tempo de execução de cada processo/thread seriam considerados para o tempo total de execução do programa.

Fora isso, o Kissat também possui uma série de parâmetros que podem ser ajustados para tentar melhorar o tempo de execução, como o número de iterações, threads utilizadas e relaxamento geral da solução. Nenhum desses foi utilizado, alguns pelos motivos acima, e o relaxamento pelo desejo do grupo de se manter o mais próximo possível da solução ótima para o problema proposto de encontrar o menor predecessor imediato de um tabuleiro do jogo da vida.

Por fim, a dupla acredita ter atingido o objetivo do trabalho e ter conseguido passar a ideia de como o problema foi abordado e resolvido, além de demonstrar o empenho e dedicação para encontrar uma solução interessante para o problema, mesmo que simples.